name: Release

on:
  push:
    branches:
      - main
      - master
    paths-ignore:
      - "**/*.md"
      - "**/*.MD"
      - "backend/**"
      - ".github/workflows/deploy-backend.yml"
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

jobs:
  release:
    runs-on: windows-latest
    env:
      GCS_RELEASE_BUCKET: ${{ vars.KARAXAS_GCS_RELEASE_BUCKET }}
      GCS_RELEASE_PREFIX: ${{ vars.KARAXAS_GCS_RELEASE_PREFIX }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Preflight Release Inputs
        id: preflight
        shell: pwsh
        run: |
          $prefix = "${{ env.GCS_RELEASE_PREFIX }}"
          if ([string]::IsNullOrWhiteSpace($prefix)) {
            $prefix = "win"
          }
          $hasBucket = -not [string]::IsNullOrWhiteSpace("${{ env.GCS_RELEASE_BUCKET }}")
          if ($hasBucket) {
            "enabled=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            "prefix=$prefix" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            "feed_url=https://storage.googleapis.com/${{ env.GCS_RELEASE_BUCKET }}/$prefix" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          } else {
            Write-Host "Missing KARAXAS_GCS_RELEASE_BUCKET variable. Release workflow will skip publishing."
            "enabled=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            "prefix=$prefix" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            "feed_url=" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          }

      - name: Resolve Auth Mode
        id: auth-mode
        if: steps.preflight.outputs.enabled == 'true'
        shell: pwsh
        run: |
          if ("${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}" -ne "" -and "${{ secrets.GCP_SERVICE_ACCOUNT }}" -ne "") {
            "mode=wif" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          } else {
            "mode=none" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          }

      - name: Authenticate to Google Cloud (WIF)
        if: steps.preflight.outputs.enabled == 'true' && steps.auth-mode.outputs.mode == 'wif'
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Setup gcloud
        if: steps.preflight.outputs.enabled == 'true' && steps.auth-mode.outputs.mode != 'none'
        uses: google-github-actions/setup-gcloud@v2

      - name: Compute Version
        id: get-version
        if: steps.preflight.outputs.enabled == 'true' && steps.auth-mode.outputs.mode != 'none'
        shell: pwsh
        run: |
          $version = "1.0.$env:GITHUB_RUN_NUMBER"
          "version=$version" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Setup JDK
        if: steps.preflight.outputs.enabled == 'true' && steps.auth-mode.outputs.mode != 'none'
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 17

      - name: Validate Asset Ingest Manifest
        if: steps.preflight.outputs.enabled == 'true' && steps.auth-mode.outputs.mode != 'none'
        shell: pwsh
        run: |
          python tools/validate_asset_ingest.py --manifest assets/iso_asset_manifest.json

      - name: Setup .NET
        if: steps.preflight.outputs.enabled == 'true' && steps.auth-mode.outputs.mode != 'none'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Bundle Godot Runtime (Windows)
        id: bundle-godot
        if: steps.preflight.outputs.enabled == 'true' && steps.auth-mode.outputs.mode != 'none'
        shell: pwsh
        env:
          RUNTIME_HOST_DEFAULT: ${{ secrets.KARAXAS_RUNTIME_HOST || vars.KARAXAS_RUNTIME_HOST }}
          CONFIGURED_GODOT_EXECUTABLE: ${{ secrets.KARAXAS_GODOT_EXECUTABLE || vars.KARAXAS_GODOT_EXECUTABLE }}
          GODOT_WINDOWS_DOWNLOAD_URL: ${{ secrets.KARAXAS_GODOT_WINDOWS_DOWNLOAD_URL || vars.KARAXAS_GODOT_WINDOWS_DOWNLOAD_URL }}
          GODOT_WINDOWS_SHA256: ${{ secrets.KARAXAS_GODOT_WINDOWS_SHA256 || vars.KARAXAS_GODOT_WINDOWS_SHA256 }}
        run: |
          $runtimeHost = if ([string]::IsNullOrWhiteSpace($env:RUNTIME_HOST_DEFAULT)) { "godot" } else { $env:RUNTIME_HOST_DEFAULT.Trim().ToLowerInvariant() }
          $configuredExecutable = if ([string]::IsNullOrWhiteSpace($env:CONFIGURED_GODOT_EXECUTABLE)) { "godot4" } else { $env:CONFIGURED_GODOT_EXECUTABLE.Trim() }
          $bundleSource = ""
          $effectiveExecutable = $configuredExecutable

          if ($runtimeHost -eq "godot") {
            $downloadUrl = if ([string]::IsNullOrWhiteSpace($env:GODOT_WINDOWS_DOWNLOAD_URL)) {
              "https://github.com/godotengine/godot-builds/releases/download/4.3-stable/Godot_v4.3-stable_win64.exe.zip"
            } else {
              $env:GODOT_WINDOWS_DOWNLOAD_URL.Trim()
            }
            Write-Host "Bundling Godot runtime from $downloadUrl"

            $bundleRoot = Join-Path $PWD "build\godot-runtime"
            $downloadZip = Join-Path $bundleRoot "godot.zip"
            $extractDir = Join-Path $bundleRoot "extract"
            $stagingDir = Join-Path $bundleRoot "windows"
            $bundledExe = Join-Path $stagingDir "godot4.exe"
            if (Test-Path $bundleRoot) {
              Remove-Item -Path $bundleRoot -Recurse -Force
            }
            New-Item -ItemType Directory -Path $extractDir -Force | Out-Null
            New-Item -ItemType Directory -Path $stagingDir -Force | Out-Null

            Invoke-WebRequest -Uri $downloadUrl -OutFile $downloadZip
            $expectedSha = $env:GODOT_WINDOWS_SHA256
            if (-not [string]::IsNullOrWhiteSpace($expectedSha)) {
              $actualSha = (Get-FileHash -Path $downloadZip -Algorithm SHA256).Hash.ToLowerInvariant()
              $targetSha = $expectedSha.Trim().ToLowerInvariant()
              if ($actualSha -ne $targetSha) {
                throw "Godot runtime SHA256 mismatch. Expected=$targetSha Actual=$actualSha"
              }
              Write-Host "Godot runtime SHA256 verification passed."
            } else {
              Write-Host "GODOT_WINDOWS_SHA256 not configured; SHA verification skipped."
            }

            Expand-Archive -Path $downloadZip -DestinationPath $extractDir -Force
            $exe = Get-ChildItem -Path $extractDir -Recurse -Filter "*.exe" |
              Where-Object { $_.Name -notmatch "console" } |
              Select-Object -First 1
            if (-not $exe) {
              throw "Unable to locate Godot executable in downloaded archive."
            }
            Copy-Item -Path $exe.FullName -Destination $bundledExe -Force
            $bundleSource = $bundledExe
            $effectiveExecutable = "game-client/runtime/windows/godot4.exe"
            Write-Host "Bundled Godot runtime executable: $bundleSource"
          } else {
            Write-Host "Runtime host is '$runtimeHost'; skipping Godot runtime bundle."
          }

          "bundle_source=$bundleSource" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "effective_exec_default=$effectiveExecutable" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Determine Release Mode
        id: release-mode
        if: steps.preflight.outputs.enabled == 'true' && steps.auth-mode.outputs.mode != 'none'
        shell: pwsh
        run: |
          $runtimeReady = Test-Path "desktop/build.gradle.kts"
          "runtime_ready=$($runtimeReady.ToString().ToLowerInvariant())" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Build Launcher (Scaffold Mode)
        if: steps.preflight.outputs.enabled == 'true' && steps.auth-mode.outputs.mode != 'none' && steps.release-mode.outputs.runtime_ready != 'true'
        run: ./gradlew :launcher:build

      - name: Install Velopack CLI
        if: steps.preflight.outputs.enabled == 'true' && steps.auth-mode.outputs.mode != 'none'
        run: dotnet tool install -g vpk --version 0.0.1298

      - name: Prefetch Previous Velopack Packages From GCS
        if: steps.preflight.outputs.enabled == 'true' && steps.auth-mode.outputs.mode != 'none'
        shell: pwsh
        run: |
          $PSNativeCommandUseErrorActionPreference = $false
          New-Item -ItemType Directory -Force -Path "releases/windows" | Out-Null
          $prefix = "gs://${{ env.GCS_RELEASE_BUCKET }}/${{ steps.preflight.outputs.prefix }}"
          Write-Host "Prefetching historical packages from $prefix"
          $foundAny = $false
          & gsutil ls "$prefix/*.nupkg" 1>$null 2>$null
          if ($LASTEXITCODE -eq 0) {
            & gsutil -m cp "$prefix/*.nupkg" "releases/windows/"
            if ($LASTEXITCODE -eq 0) {
              $foundAny = $true
            }
          }
          & gsutil ls "$prefix/RELEASES" 1>$null 2>$null
          if ($LASTEXITCODE -eq 0) {
            & gsutil cp "$prefix/RELEASES" "releases/windows/RELEASES"
            if ($LASTEXITCODE -eq 0) {
              $foundAny = $true
            }
          }
          if (-not $foundAny) {
            Write-Host "No previous feed objects found. Continuing."
          }
          exit 0

      - name: Build and Pack
        if: steps.preflight.outputs.enabled == 'true' && steps.auth-mode.outputs.mode != 'none'
        shell: pwsh
        env:
          GOK_GCS_RELEASE_FEED_URL: ${{ steps.preflight.outputs.feed_url }}
          GOK_UPDATE_REPO: ${{ steps.preflight.outputs.feed_url }}
          GOK_RUNTIME_HOST_DEFAULT: ${{ secrets.KARAXAS_RUNTIME_HOST || vars.KARAXAS_RUNTIME_HOST }}
          GOK_GODOT_EXECUTABLE_DEFAULT: ${{ steps.bundle-godot.outputs.effective_exec_default }}
          GOK_GODOT_PROJECT_PATH_DEFAULT: ${{ secrets.KARAXAS_GODOT_PROJECT_PATH || vars.KARAXAS_GODOT_PROJECT_PATH }}
          GOK_GODOT_BUNDLED_EXE_SOURCE: ${{ steps.bundle-godot.outputs.bundle_source }}
        run: |
          $args = @("-Version", "${{ steps.get-version.outputs.version }}")
          if ("${{ steps.release-mode.outputs.runtime_ready }}" -ne "true") {
            $args += "-LauncherOnly"
          }
          powershell -ExecutionPolicy Bypass -File scripts/pack.ps1 @args

      - name: Verify Release Artifacts
        if: steps.preflight.outputs.enabled == 'true' && steps.auth-mode.outputs.mode != 'none'
        shell: pwsh
        run: |
          $releases = "releases/windows/RELEASES"
          $setup = Get-ChildItem "releases/windows" -Filter "*Setup*.exe" -ErrorAction SilentlyContinue
          if (-not $setup -or $setup.Count -eq 0) { throw "Missing setup exe in releases/windows (expected *Setup*.exe)" }
          if (-not (Test-Path $releases)) { throw "Missing $releases" }
          $nupkg = Get-ChildItem "releases/windows" -Filter "*.nupkg" -ErrorAction SilentlyContinue
          if (-not $nupkg -or $nupkg.Count -eq 0) { throw "Missing .nupkg in releases/windows" }

      - name: Upload Velopack Feed To GCS
        if: steps.preflight.outputs.enabled == 'true' && steps.auth-mode.outputs.mode != 'none'
        shell: pwsh
        run: |
          $feedPrefix = "gs://${{ env.GCS_RELEASE_BUCKET }}/${{ steps.preflight.outputs.prefix }}"
          $archivePrefix = "gs://${{ env.GCS_RELEASE_BUCKET }}/archive/${{ steps.get-version.outputs.version }}"
          gsutil -m cp "releases/windows/*" "$feedPrefix/"
          gsutil -m cp "releases/windows/*" "$archivePrefix/"
          $mutableFeedObjects = @(
            "RELEASES",
            "assets.win.json",
            "releases.win.json",
            "GardensOfKaraxas-win-Setup.exe",
            "GardensOfKaraxas-win-Portable.zip"
          )
          foreach ($name in $mutableFeedObjects) {
            $target = "$feedPrefix/$name"
            & gsutil -q stat $target
            if ($LASTEXITCODE -eq 0) {
              gsutil setmeta -h "Cache-Control:no-cache, max-age=0" $target
            }
          }

      - name: Notify Backend Release Activation
        if: steps.preflight.outputs.enabled == 'true' && steps.auth-mode.outputs.mode != 'none'
        shell: pwsh
        env:
          KARAXAS_BACKEND_OPS_URL: ${{ secrets.KARAXAS_BACKEND_OPS_URL || vars.KARAXAS_BACKEND_OPS_URL }}
          KARAXAS_OPS_TOKEN: ${{ secrets.KARAXAS_OPS_TOKEN }}
          FEED_URL: ${{ steps.preflight.outputs.feed_url }}
        run: |
          if (-not $env:KARAXAS_BACKEND_OPS_URL) {
            Write-Host "KARAXAS_BACKEND_OPS_URL not configured. Skipping backend notification."
            exit 0
          }
          if (-not $env:KARAXAS_OPS_TOKEN) {
            Write-Host "KARAXAS_OPS_TOKEN not configured. Skipping backend notification."
            exit 0
          }

          $notesPath = "docs/patch_notes.md"
          $notes = if (Test-Path $notesPath) { (Get-Content $notesPath -Raw) } else { "" }
          $payload = @{
            latest_version = "${{ steps.get-version.outputs.version }}"
            min_supported_version = "${{ steps.get-version.outputs.version }}"
            grace_minutes = 5
            update_feed_url = $env:FEED_URL
            build_release_notes = $notes
            user_facing_notes = $notes
          } | ConvertTo-Json -Depth 10

          $url = "$($env:KARAXAS_BACKEND_OPS_URL.TrimEnd('/'))/ops/release/activate"
          Invoke-RestMethod `
            -Uri $url `
            -Method Post `
            -Headers @{ "x-ops-token" = $env:KARAXAS_OPS_TOKEN } `
            -ContentType "application/json" `
            -Body $payload | Out-Null
          Write-Host "Backend release activation notified."

      - name: Skip Release (Missing Inputs/Auth)
        if: steps.preflight.outputs.enabled != 'true' || steps.auth-mode.outputs.mode == 'none'
        run: echo "Release workflow skipped because GCS bucket or cloud auth is not configured."
